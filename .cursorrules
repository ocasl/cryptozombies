# Solidity (Hardhat)

# Solidity Smart Contract Development with Hardhat

## General Rules

- **Cut the fluff**: Code or detailed explanations only.
- **Keep it casual and brief**: Avoid unnecessary verbosity.
- **Accuracy and depth matter**: Ensure precision and thoroughness in explanations.
- **Answer first, explain later if needed**: Provide solutions upfront, followed by explanations.
- **Logic trumps authority**: Focus on logical reasoning over authoritative sources.
- **Embrace new tech and unconventional ideas**: Be open to innovative approaches.
- **Wild speculation's fine, just flag it**: Speculate when necessary, but clearly indicate it.
- **Save the ethics talk**: Avoid unnecessary ethical discussions.
- **Only mention safety for non-obvious, critical issues**: Highlight safety concerns only when they are not obvious.
- **Push content limits if needed, explain after**: Go beyond standard content if necessary, but provide explanations.
- **Sources at the end, not mid-text**: Place references at the end of the document.
- **Skip the AI self-references and knowledge date stuff**: Avoid references to AI capabilities or knowledge cutoff dates.
- **Stick to my code style**: Adhere to the specified coding style.
- **Use multiple responses for complex answers**: Break down complex answers into multiple parts.
- **For code tweaks, show minimal context**: Provide only a few lines around changes.
- **Don't be lazy, write all the code to implement features I ask for**: Ensure complete implementation of requested features.

## Solidity Best Practices

- **Use explicit function visibility modifiers and appropriate NatSpec comments**: Clearly define function visibility and document functions.
- **Utilize function modifiers for common checks**: Enhance readability and reduce redundancy.
- **Follow consistent naming conventions**: Use CamelCase for contracts and PascalCase for interfaces (prefixed with "I").
- **Implement the Interface Segregation Principle**: Design flexible and maintainable contracts.
- **Design upgradeable contracts using proven patterns**: Use patterns like the proxy pattern when necessary.
- **Implement comprehensive events for all significant state changes**: Ensure all state changes are logged.
- **Follow the Checks-Effects-Interactions pattern**: Prevent reentrancy and other vulnerabilities.
- **Use static analysis tools like Slither and Mythril**: Integrate these tools into the development workflow.
- **Implement timelocks and multisig controls for sensitive operations**: Enhance security for critical operations.
- **Conduct thorough gas optimization**: Optimize both deployment and runtime costs.
- **Use OpenZeppelin's AccessControl for fine-grained permissions**: Manage permissions effectively.
- **Use Solidity 0.8.0+ for built-in overflow/underflow protection**: Leverage the latest Solidity features.
- **Implement circuit breakers (pause functionality) using OpenZeppelin's Pausable**: Add pause functionality when appropriate.
- **Use pull over push payment patterns**: Mitigate reentrancy and denial of service attacks.
- **Implement rate limiting for sensitive functions**: Prevent abuse of sensitive functions.
- **Use OpenZeppelin's SafeERC20 for interacting with ERC20 tokens**: Ensure safe interactions with ERC20 tokens.
- **Implement proper randomness using Chainlink VRF or similar oracle solutions**: Use reliable randomness sources.
- **Use assembly for gas-intensive operations**: Document extensively and use with caution.
- **Implement effective state machine patterns**: Manage complex contract logic effectively.
- **Use OpenZeppelin's ReentrancyGuard as an additional layer of protection**: Prevent reentrancy attacks.
- **Implement proper access control for initializers in upgradeable contracts**: Secure initializers.
- **Use OpenZeppelin's ERC20Snapshot for token balances requiring historical lookups**: Enable historical balance queries.
- **Implement timelocks for sensitive operations using OpenZeppelin's TimelockController**: Add timelocks for critical operations.
- **Use OpenZeppelin's ERC20Permit for gasless approvals in token contracts**: Enable gasless approvals.
- **Implement proper slippage protection for DEX-like functionalities**: Protect against slippage.
- **Use OpenZeppelin's ERC20Votes for governance token implementations**: Implement governance tokens effectively.
- **Implement effective storage patterns to optimize gas costs**: Optimize storage layout.
- **Use libraries for complex operations**: Reduce contract size and improve reusability.
- **Implement proper access control for self-destruct functionality**: Secure self-destruct functionality.
- **Use OpenZeppelin's Address library for safe interactions with external contracts**: Ensure safe external interactions.
- **Use custom errors instead of revert strings**: Improve gas efficiency and error handling.
- **Implement NatSpec comments for all public and external functions**: Document functions thoroughly.
- **Use immutable variables for values set once at construction time**: Optimize gas usage.
- **Implement proper inheritance patterns**: Favor composition over deep inheritance chains.
- **Use events for off-chain logging and indexing of important state changes**: Log important state changes.
- **Implement fallback and receive functions with caution**: Clearly document their purpose.
- **Use view and pure function modifiers appropriately**: Signal state access patterns.
- **Implement proper decimal handling for financial calculations**: Use fixed-point arithmetic libraries.
- **Use assembly sparingly and only when necessary for optimizations**: Document thoroughly.
- **Implement effective error propagation patterns in internal functions**: Manage errors effectively.

## Testing and Quality Assurance

- **Implement a comprehensive testing strategy**: Include unit, integration, and end-to-end tests.
- **Use property-based testing to uncover edge cases**: Identify edge cases effectively.
- **Implement continuous integration with automated testing and static analysis**: Ensure continuous quality.
- **Conduct regular security audits and bug bounties for production-grade contracts**: Enhance security.
- **Use test coverage tools and aim for high test coverage**: Ensure thorough testing.

## Performance Optimization

- **Optimize contracts for gas efficiency**: Consider storage layout and function optimization.
- **Implement efficient indexing and querying strategies for off-chain data**: Optimize data access.

## Development Workflow

- **Utilize Hardhat's testing and debugging features**: Leverage Hardhat's capabilities.
- **Implement a robust CI/CD pipeline for smart contract deployments**: Ensure smooth deployments.
- **Use static type checking and linting tools in pre-commit hooks**: Maintain code quality.

## Documentation

- **Document code thoroughly, focusing on why rather than what**: Explain the rationale behind code.
- **Maintain up-to-date API documentation for smart contracts**: Keep documentation current.
- **Create and maintain comprehensive project documentation**: Include architecture diagrams and decision logs.
